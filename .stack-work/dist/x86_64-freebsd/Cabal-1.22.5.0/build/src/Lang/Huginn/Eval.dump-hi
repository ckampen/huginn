
==================== FINAL INTERFACE ====================
2016-12-20 11:17:51.982272 UTC

interface hugin_IqzXpp8LztLLTlnmoPtP9a:Lang.Huginn.Eval 7103
  interface hash: eeba4bc0ff679543feb07252892f8bdd
  ABI hash: 53e49023711ede88c1a2d9e636f03063
  export-list hash: 2956c2b4fe04384321721cfb67594f19
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 757622174d5a42131802338438c7b255
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lang.Huginn.Eval.add
  Lang.Huginn.Eval.calc
  Lang.Huginn.Eval.divExp
  Lang.Huginn.Eval.eq
  Lang.Huginn.Eval.evalFns
  Lang.Huginn.Eval.evals
  Lang.Huginn.Eval.exprToString
  Lang.Huginn.Eval.exprToValueTpl
  Lang.Huginn.Eval.getNumber
  Lang.Huginn.Eval.getVarValues
  Lang.Huginn.Eval.gt
  Lang.Huginn.Eval.gte
  Lang.Huginn.Eval.isTrue
  Lang.Huginn.Eval.lt
  Lang.Huginn.Eval.lte
  Lang.Huginn.Eval.mapEnvEntries
  Lang.Huginn.Eval.mul
  Lang.Huginn.Eval.pow
  Lang.Huginn.Eval.runBinary
  Lang.Huginn.Eval.runEval
  Lang.Huginn.Eval.sub
  Lang.Huginn.Eval.updateExp
  Lang.Huginn.Eval.Env{Lang.Huginn.Eval.Env Lang.Huginn.Eval.functions Lang.Huginn.Eval.vars}
  Lang.Huginn.Eval.EnvEntries
  Lang.Huginn.Eval.EnvEntry
  Lang.Huginn.Eval.EvalExpr
  Lang.Huginn.Eval.EvalM
module dependencies: Lang.Huginn.AST
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Functor 5c701b0af1708f0192a25dfe14ce6274
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Float e532d434ec2447d809887c0fca1d78a5
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  Lang.Huginn.AST 7f6fda1d887703f602a1de91a2651865
  exports: c987d63c9651ff78892aa6d1c469de01
  Add 89f4ac10514470ac0a558416d62a01f7
  Bl 9b7d60c4f240a9b58d00a952f850cba8
  Closure 096bffbddb1e5027394096be9323ae33
  Div fbac2a5419426365c6e6f7d546dcf228
  EQUALS 35b9f864f95de8d779610753b9434fa3
  Eadd bfb93db3ef5094fe0873e1065671fc10
  Ediv f617217198a0b4df287b7c42e303884c
  Eeq 5173c2f74de21c63e04050d4d7cc61c0
  Egt d3c07e7b701a09f8665f4dd5f5ccb8cd
  Egte bbfb21c3c11ee58420f4f9a7b417875b
  Elt d82703d2eb5df863d78cfa962616fe2f
  Elte 33d96465eea934c8f0a1f039b28e3de1
  Emul 0291ddbbeca5b9164ac97793fe4b632c
  Epow 56a434160fa668e07a715d9bfa6c1880
  Err 88aeb38127935704988cd7c2982c1347
  Esub 06c9e7a17140279e2a65f9b36e8d4bab
  Expr 9bf6ed4e0c9b2ea4cfd44e502502934e
  If 7b79fc1d3831c2437c8570124d5f135f
  Let 925e29fdadf05ad38c94cd5ffdce6064
  Mul 5f689df00ef278e11db53317dd5e83aa
  NaN ecc8395bf151539eba6feddde5041320
  Num 98a2516118ced8f2165570f494f144c7
  Operant 44e352eb97efd59e07e178ed7274db83
  POW 4d45db612a8d4dec4c4ef38300b79d73
  Parse 80a08ff0df978faf7d08eb42547bbfab
  Str b741b07a0d4ec9a8463706a04bc9cba1
  Sub dc9d11060e177e0420153db727f3642d
  Unbound 51beab5b61141602ab280fcbf4051628
  Uncomparable 8429138997e3b07244de9b7813341976
  Unimplemented 6d1a8249bc13959606d35ae419ff3161
  Unsupported fb2e28935d862a023b5bb5250fed3eee
  Var 47975e3edc175c4462ab8d181bf328b0
import  -/  mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8:Control.Monad.State 3c8114545920fee1e57c3d7a07c2d0d7
import  -/  mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8:Control.Monad.State.Class 71cb030be928f92f7d8f2a86db6e1cae
import  -/  transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.State.Lazy a0ae9990521f3719d0ffc837d271b7a5
825dbc9c7b6ff82443bc7c89e76fee89
  $fShowEnv :: GHC.Show.Show Lang.Huginn.Eval.Env
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lang.Huginn.Eval.Env
                  Lang.Huginn.Eval.$fShowEnv_$cshowsPrec
                  Lang.Huginn.Eval.$fShowEnv_$cshow
                  Lang.Huginn.Eval.$fShowEnv_$cshowList -}
825dbc9c7b6ff82443bc7c89e76fee89
  $fShowEnv1 :: Lang.Huginn.Eval.Env -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Lang.Huginn.Eval.Env w1 :: GHC.Base.String ->
                 case w of ww { Lang.Huginn.Eval.Env ww1 ww2 ->
                 Lang.Huginn.Eval.$w$cshowsPrec 0 ww1 ww2 w1 }) -}
825dbc9c7b6ff82443bc7c89e76fee89
  $fShowEnv_$cshow :: Lang.Huginn.Eval.Env -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lang.Huginn.Eval.Env ->
                 Lang.Huginn.Eval.$fShowEnv_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
825dbc9c7b6ff82443bc7c89e76fee89
  $fShowEnv_$cshowList :: [Lang.Huginn.Eval.Env] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lang.Huginn.Eval.Env
                   Lang.Huginn.Eval.$fShowEnv1) -}
825dbc9c7b6ff82443bc7c89e76fee89
  $fShowEnv_$cshowsPrec ::
    GHC.Types.Int -> Lang.Huginn.Eval.Env -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Lang.Huginn.Eval.Env
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lang.Huginn.Eval.Env ww3 ww4 ->
                 Lang.Huginn.Eval.$w$cshowsPrec ww1 ww3 ww4 w2 } }) -}
5e87c96dd016e85a8145dbd550dcdeb0
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> Lang.Huginn.Eval.EnvEntries
    -> Lang.Huginn.Eval.EnvEntries
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U><L,1*U><L,U>, Inline: [0] -}
4f4ff30e9dda9832afd8321bdf928dac
  $wevalFns ::
    GHC.Base.String
    -> Lang.Huginn.Eval.EnvEntries
    -> Lang.Huginn.Eval.EnvEntries
    -> Lang.Huginn.AST.Expr
  {- Arity: 3, Strictness: <L,U><L,U><S,U>, Inline: [0],
     Unfolding: (\ w :: GHC.Base.String
                   ww :: Lang.Huginn.Eval.EnvEntries
                   ww1 :: Lang.Huginn.Eval.EnvEntries ->
                 case GHC.List.lookup
                        @ GHC.Base.String
                        @ Lang.Huginn.AST.Expr
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        w
                        ww1 of wild {
                   GHC.Base.Nothing
                   -> case ((Lang.Huginn.Eval.evals
                               (Lang.Huginn.AST.Err (Lang.Huginn.AST.Unbound w)))
                              `cast`
                            (Control.Monad.Trans.State.Lazy.NTCo:StateT[0]
                                 <Lang.Huginn.Eval.Env>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <Lang.Huginn.AST.Expr>_N)
                              (Lang.Huginn.Eval.Env ww ww1))
                             `cast`
                           (Data.Functor.Identity.NTCo:Identity[0]
                                <(Lang.Huginn.AST.Expr,
                                  Lang.Huginn.Eval.Env)>_R) of wild1 { (,) x ds1 ->
                      x }
                   GHC.Base.Just v
                   -> case ((Lang.Huginn.Eval.evals v)
                              `cast`
                            (Control.Monad.Trans.State.Lazy.NTCo:StateT[0]
                                 <Lang.Huginn.Eval.Env>_N
                                 <Data.Functor.Identity.Identity>_R
                                 <Lang.Huginn.AST.Expr>_N)
                              (Lang.Huginn.Eval.Env ww ww1))
                             `cast`
                           (Data.Functor.Identity.NTCo:Identity[0]
                                <(Lang.Huginn.AST.Expr,
                                  Lang.Huginn.Eval.Env)>_R) of wild1 { (,) x ds1 ->
                      x } }) -}
bb3370f34e40658319fe4b701efde40c
  $wgetVarValues ::
    GHC.Base.String
    -> Lang.Huginn.Eval.EnvEntries
    -> Lang.Huginn.Eval.EnvEntries
    -> Lang.Huginn.AST.Expr
  {- Arity: 3, Strictness: <L,U><S,U><L,U>, Inline: [0],
     Unfolding: (\ w :: GHC.Base.String
                   ww :: Lang.Huginn.Eval.EnvEntries
                   ww1 :: Lang.Huginn.Eval.EnvEntries ->
                 case GHC.List.lookup
                        @ GHC.Base.String
                        @ Lang.Huginn.AST.Expr
                        GHC.Classes.$fEq[]_$s$fEq[]1
                        w
                        ww of wild {
                   GHC.Base.Nothing -> Lang.Huginn.Eval.$wevalFns w ww ww1
                   GHC.Base.Just v -> v }) -}
825dbc9c7b6ff82443bc7c89e76fee89
  data Env
    = Env {vars :: Lang.Huginn.Eval.EnvEntries,
           functions :: Lang.Huginn.Eval.EnvEntries}
fa09adcfa0b954f925a9731662827d0f
  type EnvEntries = [Lang.Huginn.Eval.EnvEntry]
15183993cb11d1576c20aaddf60d0c70
  type EnvEntry = (GHC.Base.String, Lang.Huginn.AST.Expr)
4eb3f3b5152556aab24cc966c7190571
  type EvalExpr = (Lang.Huginn.AST.Expr, Lang.Huginn.Eval.Env)
65df42256bb8918c0af0d650be4958e9
  type EvalM =
    Control.Monad.Trans.State.Lazy.State
      Lang.Huginn.Eval.Env Lang.Huginn.AST.Expr
079f61918f0f764871d90946754dcbff
  add ::
    Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Lang.Huginn.AST.Expr ds1 :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.add1
                   Lang.Huginn.AST.Num a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.add1
                        Lang.Huginn.AST.Num b
                        -> Lang.Huginn.AST.Num (GHC.Float.plusDouble a10 b) } }) -}
71d97fde6be8b4485de3ba1cf5cf98dc
  add1 :: Lang.Huginn.AST.Expr
  {- HasNoCafRefs, Strictness: m11,
     Unfolding: (Lang.Huginn.AST.Err Lang.Huginn.AST.NaN) -}
0560b4f78239c0a6c301e0ae25bbf808
  calc ::
    Lang.Huginn.AST.Operant
    -> Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,1*U> -}
9f271dab5b8b225585a47ed8e7e28ac2
  divExp ::
    Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Lang.Huginn.AST.Expr ds1 :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.add1
                   Lang.Huginn.AST.Num a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.add1
                        Lang.Huginn.AST.Num b
                        -> Lang.Huginn.AST.Num (GHC.Float.divideDouble a10 b) } }) -}
df64dfde8a4cce479421f0203b641fe7
  eq ::
    Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ ds :: Lang.Huginn.AST.Expr
                   ds1 :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.eq1
                   Lang.Huginn.AST.Num a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Num b
                        -> Lang.Huginn.AST.Bl (GHC.Classes.$fEqDouble_$c== a10 b) }
                   Lang.Huginn.AST.Str a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Str b
                        -> Lang.Huginn.AST.Bl (GHC.Base.eqString a10 b) }
                   Lang.Huginn.AST.Bl a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Bl b
                        -> Lang.Huginn.AST.Bl (GHC.Classes.$fEqBool_$c== a10 b) } }) -}
b57f73473d3bf16c584a3be6894361d7
  eq1 :: Lang.Huginn.AST.Expr
  {- HasNoCafRefs, Strictness: m11,
     Unfolding: (Lang.Huginn.AST.Err Lang.Huginn.AST.Uncomparable) -}
8895d36343323f9f18a3af7a49447b88
  evalFns ::
    GHC.Base.String -> Lang.Huginn.Eval.Env -> Lang.Huginn.AST.Expr
  {- Arity: 2, Strictness: <L,U><S(LS),U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Base.String w1 :: Lang.Huginn.Eval.Env ->
                 case w1 of ww { Lang.Huginn.Eval.Env ww1 ww2 ->
                 Lang.Huginn.Eval.$wevalFns w ww1 ww2 }) -}
bfb3d0c93bc473cf24b2b6cf96b60527
  evals :: Lang.Huginn.AST.Expr -> Lang.Huginn.Eval.EvalM
  {- Arity: 1, Strictness: <S,1*U> -}
be7bfa8b44488684b7f37d96adb7b7e7
  exprToString :: Lang.Huginn.AST.Expr -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.exprToString3
                   Lang.Huginn.AST.Num n -> GHC.Float.$fShowDouble_$cshow n
                   Lang.Huginn.AST.Str n -> GHC.Show.$fShow[]_$s$cshow1 n
                   Lang.Huginn.AST.Bl ds1
                   -> case ds1 of wild1 {
                        GHC.Types.False -> Lang.Huginn.Eval.exprToString2
                        GHC.Types.True -> Lang.Huginn.Eval.exprToString1 } }) -}
271e4df801bef690695833f6a8c89929
  exprToString1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "true"#) -}
104b384d4424f532a5f58320ae9bd46c
  exprToString2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "false"#) -}
efa6f67348f6b3f7a41c7cbe37c8d58b
  exprToString3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Error"#) -}
f6576deea5eddccc0f1cce5ef5280ae4
  exprToValueTpl ::
    Lang.Huginn.AST.Expr -> (GHC.Base.String, GHC.Base.String)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Lang.Huginn.AST.Expr ->
                 case w of wild {
                   DEFAULT
                   -> (Lang.Huginn.Eval.exprToValueTpl4,
                       Lang.Huginn.Eval.exprToString3)
                   Lang.Huginn.AST.Num n
                   -> (Lang.Huginn.Eval.exprToValueTpl3,
                       GHC.Float.$fShowDouble_$cshow n)
                   Lang.Huginn.AST.Str n
                   -> (Lang.Huginn.Eval.exprToValueTpl2,
                       GHC.Show.$fShow[]_$s$cshow1 n)
                   Lang.Huginn.AST.Bl ds
                   -> case ds of wild1 {
                        GHC.Types.False
                        -> (Lang.Huginn.Eval.exprToValueTpl1,
                            Lang.Huginn.Eval.exprToString2)
                        GHC.Types.True
                        -> (Lang.Huginn.Eval.exprToValueTpl1,
                            Lang.Huginn.Eval.exprToString1) } }) -}
dbc82c485980464ae625beebe29ff0ff
  exprToValueTpl1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "bool"#) -}
8779b78d5b3132faa75b83be9c413006
  exprToValueTpl2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "string"#) -}
25f388d6574f2514a654ccd4c4c3fc2e
  exprToValueTpl3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "float"#) -}
b9f47f24afcc557a655d7d9b7e915435
  exprToValueTpl4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "error"#) -}
cea1c64a55a0fae675c1c10e060f9b31
  functions :: Lang.Huginn.Eval.Env -> Lang.Huginn.Eval.EnvEntries
  RecSel Lang.Huginn.Eval.Env
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Lang.Huginn.Eval.Env ->
                 case ds of wild { Lang.Huginn.Eval.Env ds1 ds2 -> ds2 }) -}
e92a3c8621b7787361d54612d5b57cde
  getNumber :: Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.add1
                   Lang.Huginn.AST.Num fl -> Lang.Huginn.AST.Num fl
                   Lang.Huginn.AST.Bl ds1
                   -> case ds1 of wild1 {
                        GHC.Types.False -> Lang.Huginn.Eval.getNumber3
                        GHC.Types.True -> Lang.Huginn.Eval.getNumber1 } }) -}
f2041451f04ca33706a28402348277ea
  getNumber1 :: Lang.Huginn.AST.Expr
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Lang.Huginn.AST.Num Lang.Huginn.Eval.getNumber2) -}
8a589589c8bd91d91157f0d7741daccc
  getNumber2 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 1.0) -}
e17e59daaa12b7b2e6a840ad1a25ccaa
  getNumber3 :: Lang.Huginn.AST.Expr
  {- HasNoCafRefs, Strictness: m3,
     Unfolding: (Lang.Huginn.AST.Num Lang.Huginn.Eval.getNumber4) -}
1407b807a1735637a3db14a9d182dc5e
  getNumber4 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 0.0) -}
b04351ecc4b3772fd38f625c1dd7b9f2
  getVarValues ::
    GHC.Base.String -> Lang.Huginn.Eval.Env -> Lang.Huginn.AST.Expr
  {- Arity: 2, Strictness: <L,U><S(SL),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Base.String w1 :: Lang.Huginn.Eval.Env ->
                 case w1 of ww { Lang.Huginn.Eval.Env ww1 ww2 ->
                 Lang.Huginn.Eval.$wgetVarValues w ww1 ww2 }) -}
0224f14736968dfc0e6217840193ba79
  gt ::
    Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ ds :: Lang.Huginn.AST.Expr
                   ds1 :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.eq1
                   Lang.Huginn.AST.Num a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Num b
                        -> Lang.Huginn.AST.Bl (GHC.Classes.$fOrdDouble_$c> a10 b) }
                   Lang.Huginn.AST.Str a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Str b
                        -> Lang.Huginn.AST.Bl (GHC.Classes.$fOrd[]_$s$c>1 a10 b) } }) -}
4bf13c6616ae0144379d9578708ebf50
  gte ::
    Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ ds :: Lang.Huginn.AST.Expr
                   ds1 :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.eq1
                   Lang.Huginn.AST.Num a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Num b
                        -> Lang.Huginn.AST.Bl (GHC.Classes.$fOrdDouble_$c>= a10 b) }
                   Lang.Huginn.AST.Str a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Str b
                        -> Lang.Huginn.AST.Bl (GHC.Classes.$fOrd[]_$s$c>=1 a10 b) } }) -}
ba43f86bcae7039a565fe456a6f11f84
  isTrue :: Lang.Huginn.AST.Expr -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False Lang.Huginn.AST.Bl ds1 -> ds1 }) -}
b55f7204936bd3d3c7c0500eaa19c0a8
  lt ::
    Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ ds :: Lang.Huginn.AST.Expr
                   ds1 :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.eq1
                   Lang.Huginn.AST.Num a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Num b
                        -> Lang.Huginn.AST.Bl (GHC.Classes.$fOrdDouble_$c< a10 b) }
                   Lang.Huginn.AST.Str a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Str b
                        -> Lang.Huginn.AST.Bl (GHC.Classes.$fOrd[]_$s$c<1 a10 b) } }) -}
5a582bf1d87a13adc15e72892fba5b24
  lte ::
    Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ ds :: Lang.Huginn.AST.Expr
                   ds1 :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.eq1
                   Lang.Huginn.AST.Num a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Num b
                        -> Lang.Huginn.AST.Bl (GHC.Classes.$fOrdDouble_$c<= a10 b) }
                   Lang.Huginn.AST.Str a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.eq1
                        Lang.Huginn.AST.Str b
                        -> Lang.Huginn.AST.Bl (GHC.Classes.$fOrd[]_$s$c<=1 a10 b) } }) -}
187ca923826b7a7f98b21b244f5ba1a6
  mapEnvEntries ::
    (GHC.Base.String, Data.Either.Either t Lang.Huginn.AST.Expr)
    -> Lang.Huginn.Eval.EnvEntry
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ t
                   ds :: (GHC.Base.String,
                          Data.Either.Either t Lang.Huginn.AST.Expr) ->
                 case ds of wild { (,) n ds1 ->
                 case ds1 of wild1 {
                   Data.Either.Left ds2 -> (n, Lang.Huginn.Eval.mapEnvEntries1)
                   Data.Either.Right ex -> (n, ex) } }) -}
e0342e2e75527fd92f00a8d890662163
  mapEnvEntries1 :: Lang.Huginn.AST.Expr
  {- HasNoCafRefs, Strictness: m11,
     Unfolding: (Lang.Huginn.AST.Err Lang.Huginn.AST.Parse) -}
1943748f74b284b9abca62e128833de0
  mul ::
    Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Lang.Huginn.AST.Expr ds1 :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.add1
                   Lang.Huginn.AST.Num a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.add1
                        Lang.Huginn.AST.Num b
                        -> Lang.Huginn.AST.Num (GHC.Float.timesDouble a10 b) } }) -}
9b82f3e514e92487c35d5ca7e9e13402
  pow ::
    Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Lang.Huginn.AST.Expr ds1 :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.add1
                   Lang.Huginn.AST.Num a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.add1
                        Lang.Huginn.AST.Num b
                        -> Lang.Huginn.AST.Num (GHC.Float.powerDouble a10 b) } }) -}
b05c01da35dc64184a0ca388aa647c98
  runBinary ::
    (Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr -> t)
    -> Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr
    -> Lang.Huginn.Eval.Env
    -> t
  {- Arity: 4, Strictness: <C(C(S)),1*C1(C1(U))><L,1*U><L,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ t
                   op :: Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr -> t
                   left :: Lang.Huginn.AST.Expr
                   right :: Lang.Huginn.AST.Expr
                   env :: Lang.Huginn.Eval.Env ->
                 op
                   (case ((Lang.Huginn.Eval.evals left)
                            `cast`
                          (Control.Monad.Trans.State.Lazy.NTCo:StateT[0]
                               <Lang.Huginn.Eval.Env>_N
                               <Data.Functor.Identity.Identity>_R
                               <Lang.Huginn.AST.Expr>_N)
                            env)
                           `cast`
                         (Data.Functor.Identity.NTCo:Identity[0]
                              <(Lang.Huginn.AST.Expr,
                                Lang.Huginn.Eval.Env)>_R) of wild { (,) x ds1 ->
                    x })
                   (case ((Lang.Huginn.Eval.evals right)
                            `cast`
                          (Control.Monad.Trans.State.Lazy.NTCo:StateT[0]
                               <Lang.Huginn.Eval.Env>_N
                               <Data.Functor.Identity.Identity>_R
                               <Lang.Huginn.AST.Expr>_N)
                            env)
                           `cast`
                         (Data.Functor.Identity.NTCo:Identity[0]
                              <(Lang.Huginn.AST.Expr,
                                Lang.Huginn.Eval.Env)>_R) of wild { (,) x ds1 ->
                    x })) -}
d100238b8bff87dafa3fb021b577ae04
  runEval ::
    Lang.Huginn.Eval.Env
    -> Lang.Huginn.AST.Expr
    -> (Lang.Huginn.AST.Expr, Lang.Huginn.Eval.Env)
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Lang.Huginn.Eval.runEval1
                  `cast`
                (<Lang.Huginn.Eval.Env>_R
                 ->_R <Lang.Huginn.AST.Expr>_R
                 ->_R Data.Functor.Identity.NTCo:Identity[0]
                          <(Lang.Huginn.AST.Expr, Lang.Huginn.Eval.Env)>_R) -}
ae928ee0cb37123acc7cb2bfbe88c7c9
  runEval1 ::
    Lang.Huginn.Eval.Env
    -> Lang.Huginn.AST.Expr
    -> Data.Functor.Identity.Identity
         (Lang.Huginn.AST.Expr, Lang.Huginn.Eval.Env)
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ env :: Lang.Huginn.Eval.Env e :: Lang.Huginn.AST.Expr ->
                 (Lang.Huginn.Eval.evals e)
                   `cast`
                 (Control.Monad.Trans.State.Lazy.NTCo:StateT[0]
                      <Lang.Huginn.Eval.Env>_N
                      <Data.Functor.Identity.Identity>_R
                      <Lang.Huginn.AST.Expr>_N)
                   env) -}
5596e29b31f1991fe8dc948969c3a460
  sub ::
    Lang.Huginn.AST.Expr
    -> Lang.Huginn.AST.Expr -> Lang.Huginn.AST.Expr
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Lang.Huginn.AST.Expr ds1 :: Lang.Huginn.AST.Expr ->
                 case ds of wild {
                   DEFAULT -> Lang.Huginn.Eval.add1
                   Lang.Huginn.AST.Num a10
                   -> case ds1 of wild1 {
                        DEFAULT -> Lang.Huginn.Eval.add1
                        Lang.Huginn.AST.Num b
                        -> Lang.Huginn.AST.Num (GHC.Float.minusDouble a10 b) } }) -}
3e7aaa43e3dd220ba3bab37d7f869f42
  updateExp ::
    GHC.Base.String
    -> Lang.Huginn.Eval.EvalExpr -> Lang.Huginn.Eval.EvalExpr
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,U(1*U,1*U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ n :: GHC.Base.String
                   ds :: (Lang.Huginn.AST.Expr, Lang.Huginn.Eval.Env) ->
                 case ds of wild { (,) e v ->
                 (e,
                  Lang.Huginn.Eval.Env
                    (GHC.Types.:
                       @ (GHC.Base.String, Lang.Huginn.AST.Expr)
                       (n, e)
                       (case v of wild1 { Lang.Huginn.Eval.Env ds1 ds2 -> ds1 }))
                    (case v of wild1 { Lang.Huginn.Eval.Env ds1 ds2 -> ds2 })) }) -}
b5f74ce9e1b73d6254c0daa756276a4f
  vars :: Lang.Huginn.Eval.Env -> Lang.Huginn.Eval.EnvEntries
  RecSel Lang.Huginn.Eval.Env
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Lang.Huginn.Eval.Env ->
                 case ds of wild { Lang.Huginn.Eval.Env ds1 ds2 -> ds1 }) -}
instance GHC.Show.Show [Lang.Huginn.Eval.Env]
  = Lang.Huginn.Eval.$fShowEnv
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

